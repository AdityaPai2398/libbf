<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>libbf by mavam</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>libbf</h1>
          <h2>Bloom filters for C++11</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/mavam/libbf/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/mavam/libbf/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/mavam/libbf" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <p><strong>libbf</strong> is a C++11 library which implements various Bloom filters, including:</p>

<ul>
<li>Basic</li>
<li>Counting</li>
<li>Spectral MI</li>
<li>Spectral RM</li>
<li>Bitwise</li>
<li>A^2</li>
<li>Stable</li>
</ul><p>You can find an overview of these different Bloom filter types <a href="http://matthias.vallentin.net/blog/2011/06/a-garden-variety-of-bloom-filters/">at my
blog</a>.</p>

<h1>
<a name="synopsis" class="anchor" href="#synopsis"><span class="octicon octicon-link"></span></a>Synopsis</h1>

<pre><code>#include &lt;iostream&gt;
#include &lt;bf.h&gt;

int main()
{
  bf::basic_bloom_filter b(0.8, 100);

  // Add two elements.
  b.add("foo");
  b.add(42);

  // Test set membership
  std::cout &lt;&lt; b.lookup("foo") &lt;&lt; std::endl;  // 1
  std::cout &lt;&lt; b.lookup("bar") &lt;&lt; std::endl;  // 0
  std::cout &lt;&lt; b.lookup(42) &lt;&lt; std::endl;     // 1

  // Remove all elements.
  b.clear();
  std::cout &lt;&lt; b.lookup("foo") &lt;&lt; ' ' &lt;&lt; b.lookup(42) &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<h1>
<a name="requirements" class="anchor" href="#requirements"><span class="octicon octicon-link"></span></a>Requirements</h1>

<ul>
<li>A C++11 copmiler (GCC &gt;= 4.7 or Clang &gt;= 3.2)</li>
<li>CMake (&gt;= 2.8)</li>
<li>Boost (&gt;= 1.46) (optional, for unit testing)</li>
</ul><h1>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h1>

<p>The build process uses CMake, wrapped in autotools-like scripts. The configure
script honors the <code>CXX</code> environment variable to select a specific C++compiler.
For example, to compile libbf with Clang, install it under <code>PREFIX</code>,  and use a
Boost installation in the custom prefix <code>PREFIX</code>, use the following commands:</p>

<pre><code>export CXX=clang++
./configure --prefix=PREFIX --with-boost=PREFIX
make
make test
make install
</code></pre>

<h1>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h1>

<p>After having installed libbf, you can use it in your application by including
the header file <code>bf.h</code> and linking against the library. All data structures
reside in the namespace <code>bf</code> and the following examples assume:</p>

<pre><code>using namespace bf;
</code></pre>

<p>Each Bloom filter inherits from the abstract base class <code>bloom_filter</code>, which
provides addition and lookup via the virtual functions <code>add</code> and <code>lookup</code>.
These functions take an <code>object</code> as argument, which is a lightweight view over
sequential data that can be hashed.</p>

<p>For example, if you can create a basic Bloom filter with a desired
false-positive probability and capacity as follows:</p>

<pre><code>// Construction.
bloom_filter* bf = new basic_bloom_filter(0.8, 100);

// Addition.
bf-&gt;add("foo");
bf-&gt;add(42);

// Lookup.
assert(bf-&gt;lookup("foo") == 1);
assert(bf-&gt;lookup(42) == 1);

// Remove all elements from the Bloom filter.
bf-&gt;clear();
</code></pre>

<p>In this case, libbf computes the optimal number of hash functions needed to
achieve the desired false-positive rate which holds until the capacity has been
reached (80% and 100 distinct elements, in the above example). Alternatively,
you can construct a basic Bloom filter by exactly specifying the number of hash
functions and the number of cells in the underlying bit vector:</p>

<pre><code>bloom_filter* bf = new basic_bloom_filter(make_hasher(3), 1024);
</code></pre>

<p>Since not all Bloom filter implementations come with closed-form solutions
based on false-positive probabilities, most constructor will use this latter
form of explicit resource provisioning.</p>

<p>In the above example, the free function <code>make_hasher</code> constructs a <em>hasher</em>,
an abstraction for hashing objects <em>k</em> times. There exist currently two
different hasher, the <code>default_hasher</code> and the <code>double_hasher</code>. The latter uses
a linear combination of two pairwise-independent, universal hash functions to
produce the <em>k</em> digests, whereas the default hasher merely hashes the object
<em>k</em> times.</p>

<h2>
<a name="evaluation" class="anchor" href="#evaluation"><span class="octicon octicon-link"></span></a>Evaluation</h2>

<p>libbf also ships with a small Bloom filter tool <code>bf</code> in the test directory.
This program supports evaluation the accuracy of the different Bloom filter
flavors with respect to their false-positive and false-negative rates. Have a
look at the console help (<code>-h</code> or <code>--help</code>) for detailed usage instructions.</p>

<p>The tool operates in two phases:</p>

<ol>
<li>Read input from a file and insert it into a Bloom filter</li>
<li>Query the Bloom filter and compare the result to the ground truth</li>
</ol><p>For example, consider the following input file:</p>

<pre><code>foo
bar
baz
baz
foo
</code></pre>

<p>From this input file, you can generate the real ground truth file as follows:</p>

<pre><code>sort input.txt | uniq -c | tee query.txt
   1 bar
   2 baz
   2 foo
</code></pre>

<p>The tool <code>bf</code> will compute false-positive and false-negative counts for each
element, based on the ground truth given. In the case of a simple counting
Bloom filter, an invocation may look like this:</p>

<pre><code>bf -t counting -m 2 -k 3 -i input.txt -q query.txt | column -t
</code></pre>

<p>Yielding the following output:</p>

<pre><code>TN  TP  FP  FN  G  C  E
0   1   0   0   1  1  bar
0   1   0   1   2  1  baz
0   1   0   2   2  1  foo
</code></pre>

<p>The column headings denote true negatives (<code>TN</code>), true positives (<code>TP</code>), false
positives (<code>FP</code>), false negatives (<code>FN</code>), ground truth count (<code>G</code>), actual
count (<code>C</code>), and the queried element. The counts are cumulative to support
incremental evaluation.</p>

<h1>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h1>

<p>libbf comes with a BSD-style license (see <a href="COPYING">COPYING</a> for details).</p>
        </section>

        <footer>
          libbf is maintained by <a href="https://github.com/mavam">mavam</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>