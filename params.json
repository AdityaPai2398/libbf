{"name":"libbf","tagline":"Bloom filters for C++11","body":"**libbf** is a C++11 library which implements [various Bloom\r\nfilters][blog-post], including:\r\n\r\n- Basic\r\n- Counting\r\n- Spectral MI\r\n- Spectral RM\r\n- Bitwise\r\n- A^2\r\n- Stable\r\n\r\n[blog-post]: http://matthias.vallentin.net/blog/2011/06/a-garden-variety-of-bloom-filters/\r\n\r\nSynopsis\r\n========\r\n\r\n    #include <iostream>\r\n    #include <bf.h>\r\n\r\n    int main()\r\n    {\r\n      bf::basic_bloom_filter b(0.8, 100);\r\n\r\n      // Add two elements.\r\n      b.add(\"foo\");\r\n      b.add(42);\r\n\r\n      // Test set membership\r\n      std::cout << b.lookup(\"foo\") << std::endl;  // 1\r\n      std::cout << b.lookup(\"bar\") << std::endl;  // 0\r\n      std::cout << b.lookup(42) << std::endl;     // 1\r\n\r\n      // Remove all elements.\r\n      b.clear();\r\n      std::cout << b.lookup(\"foo\") << std::endl;  // 0\r\n      std::cout << b.lookup(42) << std::endl;     // 0\r\n\r\n      return 0;\r\n    }\r\n\r\nRequirements\r\n============\r\n\r\n- A C++11 copmiler (GCC >= 4.7 or Clang >= 3.2)\r\n- CMake (>= 2.8)\r\n- Boost (>= 1.46) *(optional, for unit testing)*\r\n\r\nInstallation\r\n============\r\n\r\nThe build process uses CMake, wrapped in autotools-like scripts. The configure\r\nscript honors the `CXX` environment variable to select a specific C++compiler.\r\nFor example, to compile libbf with Clang, install it under `PREFIX`,  and use a\r\nBoost installation in the custom prefix `PREFIX`, use the following commands:\r\n\r\n    export CXX=clang++\r\n    ./configure --prefix=PREFIX --with-boost=PREFIX\r\n    make\r\n    make test\r\n    make install\r\n\r\nDocumentation\r\n=============\r\n\r\nThe most recent version of the Doxygen API documentation exists at\r\n<http://mavam.github.io/libbf/api>. Alternatively, you can build the\r\ndocumentation locally via `make doc` and then browse to\r\n`doc/gh-pages/api/index.html`.\r\n\r\nUsage\r\n=====\r\n\r\nAfter having installed libbf, you can use it in your application by including\r\nthe header file `bf.h` and linking against the library. All data structures\r\nreside in the namespace `bf` and the following examples assume:\r\n\r\n    using namespace bf;\r\n\r\nEach Bloom filter inherits from the abstract base class `bloom_filter`, which\r\nprovides addition and lookup via the virtual functions `add` and `lookup`.\r\nThese functions take an *object* as argument, which serves a light-weight view\r\nover sequential data for hashing.\r\n\r\nFor example, if you can create a basic Bloom filter with a desired\r\nfalse-positive probability and capacity as follows:\r\n\r\n    // Construction.\r\n    bloom_filter* bf = new basic_bloom_filter(0.8, 100);\r\n\r\n    // Addition.\r\n    bf->add(\"foo\");\r\n    bf->add(42);\r\n\r\n    // Lookup.\r\n    assert(bf->lookup(\"foo\") == 1);\r\n    assert(bf->lookup(42) == 1);\r\n\r\n    // Remove all elements from the Bloom filter.\r\n    bf->clear();\r\n\r\nIn this case, libbf computes the optimal number of hash functions needed to\r\nachieve the desired false-positive rate which holds until the capacity has been\r\nreached (80% and 100 distinct elements, in the above example). Alternatively,\r\nyou can construct a basic Bloom filter by specifying the number of hash\r\nfunctions and the number of cells in the underlying bit vector:\r\n\r\n    bloom_filter* bf = new basic_bloom_filter(make_hasher(3), 1024);\r\n\r\nSince not all Bloom filter implementations come with closed-form solutions\r\nbased on false-positive probabilities, most constructors use this latter form\r\nof explicit resource provisioning.\r\n\r\nIn the above example, the free function `make_hasher` constructs a *hasher*-an\r\nabstraction for hashing objects *k* times. There exist currently two different\r\nhasher, a `default_hasher` and a\r\n[`double_hasher`](http://www.eecs.harvard.edu/~kirsch/pubs/bbbf/rsa.pdf). The\r\nlatter uses a linear combination of two pairwise-independent, universal hash\r\nfunctions to produce the *k* digests, whereas the former merely hashes the\r\nobject *k* times.\r\n\r\nEvaluation\r\n----------\r\n\r\nlibbf also ships with a small Bloom filter tool `bf` in the test directory.\r\nThis program supports evaluation the accuracy of the different Bloom filter\r\nflavors with respect to their false-positive and false-negative rates. Have a\r\nlook at the console help (`-h` or `--help`) for detailed usage instructions.\r\n\r\nThe tool operates in two phases:\r\n\r\n1. Read input from a file and insert it into a Bloom filter\r\n2. Query the Bloom filter and compare the result to the ground truth\r\n\r\nFor example, consider the following input file:\r\n\r\n    foo\r\n    bar\r\n    baz\r\n    baz\r\n    foo\r\n\r\nFrom this input file, you can generate the real ground truth file as follows:\r\n\r\n    sort input.txt | uniq -c | tee query.txt\r\n       1 bar\r\n       2 baz\r\n       2 foo\r\n\r\nThe tool `bf` will compute false-positive and false-negative counts for each\r\nelement, based on the ground truth given. In the case of a simple counting\r\nBloom filter, an invocation may look like this:\r\n\r\n    bf -t counting -m 2 -k 3 -i input.txt -q query.txt | column -t\r\n\r\nYielding the following output:\r\n\r\n    TN  TP  FP  FN  G  C  E\r\n    0   1   0   0   1  1  bar\r\n    0   1   0   1   2  1  baz\r\n    0   1   0   2   2  1  foo\r\n\r\nThe column headings denote true negatives (`TN`), true positives (`TP`), false\r\npositives (`FP`), false negatives (`FN`), ground truth count (`G`), actual\r\ncount (`C`), and the queried element. The counts are cumulative to support\r\nincremental evaluation.\r\n\r\nLicense\r\n========\r\n\r\nlibbf comes with a BSD-style license (see [COPYING](COPYING) for details).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}